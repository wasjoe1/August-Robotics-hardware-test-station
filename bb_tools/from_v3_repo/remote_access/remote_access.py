#!/usr/bin/env python
from __future__ import print_function

import os
import subprocess
from subprocess import CalledProcessError
import json
import re
import time
import argparse
import random

import settings


CURRENT_FOLDER = os.path.dirname(os.path.abspath(__file__))


class RemoteAccess:
    """
    Initializes the remote access from Lionel PC to
    any remote computer
    """
    def __init__(self, port, username):
        self.lan_port = port
        self.username = username
        _ngrok_present, self.ngrok_path, self.ngrok_config_path = self.check_ngrok_present()
        assert _ngrok_present is True, "No ngrok exists"

    def check_ngrok_present(self):
        """ Checks if the ngrok exe is present """
        ngrok_path = os.path.join(CURRENT_FOLDER, 'ngrok')
        ngrok_config_path = os.path.join(CURRENT_FOLDER, 'config.yml')
        return [
            os.path.exists(ngrok_path) and os.path.exists(ngrok_config_path),
            ngrok_path,
            ngrok_config_path
        ]

    def _run_ngrok(self):
        """ Return True/False whether run ngrok succeeded"""

        token_idxes = range(len(settings.TOKEN_POOL))

        # Random get token from pool, try to balance usage for all tokens
        while len(token_idxes) > 0:
            token_idx = random.choice(token_idxes)
            token = settings.TOKEN_POOL[token_idx]

            target_tunnels = ['ssh-access',]
            if self.username == 'guiding' and settings.IS_CB:
                target_tunnels.append('website_cb')
            else:
                target_tunnels.append('website')
            _tunnels = ' '.join(target_tunnels)

            # This command initiates the ngrok connection
            ngrok_cmd = '{} start --config="{}" --authtoken="{}" --region="{}" {}'.format(
                self.ngrok_path, self.ngrok_config_path, token, settings.REGION, _tunnels)
            ngrok_proc = subprocess.Popen(args=ngrok_cmd, stdout=subprocess.PIPE, shell=True)

            # Check process status is running in 8 seconds. If all good, it means it's running
            # as expected.
            running_slots = []
            time.sleep(3)
            for _i in range(5):
                poll_s = ngrok_proc.poll() is None
                running_slots.append(poll_s)
                if poll_s is False:
                    break
                time.sleep(1.0)

            if all(running_slots):
                print("Using token: {}".format(token))
                return True
            else:
                # Token is used by somewhere else.
                token_idxes.remove(token_idx)

        return False


    def generate_link(self):
        """ Checks and generates the ngrok ssh link """
        # 1.
        # Check connection status (Link will only be generated when successfully connected)
        connected_to_line = False
        connection_counter = 0

        # Check port availability
        while connected_to_line is False:
            # Use network manager to view connected ethernet port
            nmcli_grep_cmd = "nmcli dev status | grep {}".format(self.lan_port)
            # Output is piped into next process to be checked
            check_connected = subprocess.Popen(
                args=nmcli_grep_cmd, stdout=subprocess.PIPE, shell=True)
            (check_connected_out, err) = check_connected.communicate()

            if "connected" in check_connected_out:
                connected_to_line = True
                break
            else:
                connection_counter += 1

            if connection_counter > 20:
                print("Plugged in but taking too long to connect, please unplug, and plug again")
                return "<Unable to retrive link, please re-plug>"
            time.sleep(0.5)

        assert connected_to_line is True

        # 2.
        ngrok_running = self._run_ngrok()
        if ngrok_running is False:
            print("Ngrok failed. All tokens are in usage.")
            return "<Ngrok failed. All tokens are in usage.>"

        # 3.
        # It's better use `requests`, but we didn't install it by default on PCs.
        # To make life easier, use `curl` cmd instead.
        # The `localhost:4040` is matched `web_addr` in `config.yml`
        extract_cmd = 'curl -k -H "Content-Type: application/json" localhost:4040/api/tunnels'
        # Command to extract the ngrok generated link
        tcp_url = ""
        https_url = ""

        # Checking if the link has been generated by looking for keyword tcp
        timeout_connection = 0
        while True:
            try:
                out = subprocess.check_output(extract_cmd, shell=True)
                jstr = json.loads(out)
                for tunnel in jstr["tunnels"]:
                    proto = tunnel['proto']
                    if proto == 'https':
                        https_url = tunnel['public_url']
                    elif proto == 'tcp':
                        tcp_url = tunnel['public_url']
                if tcp_url and https_url:
                    break
            except Exception as e:
                timeout_connection += 1

            time.sleep(3) # Reduce loading statements
            if timeout_connection > 20:
                print("Cannot connect to ngrok tunnel. Please unplug and plug again")
                return "<Unable to connec to ngrok. please re-plug>"

        #  Regex to extract the URL and PORT
        regex = r'tcp:\/\/(?P<url>.*):(?P<port>.*)'
        g = re.match(regex, tcp_url)

        #  Form the SSH Command
        ssh_cmd = ("https URL: {}\n"
                   "ssh {}@{} -p{}").format(
                       https_url, self.username.rstrip(), g.group("url"), g.group("port"))
        return ssh_cmd

    def send_link(self, generated_link, location):
        """ Send the generated link via Dingtalk notif """
        # Get machine name
        machine_name = os.uname()[1]
        # Alert on RemoteBot Chat
        curl_cmd = ("curl -k 'https://oapi.dingtalk.com/robot/send?access_token={0}' -H "
                    "'Content-Type: application/json' "
                    "-d '{{\"msgtype\":\"text\", \"text\": "
                    "{{ \"content\":\"RemoteBot:\n{1}\nPC: {2}\nLocation: {3}\" }}}}'").format(
                        settings.DINGTALK_TOKEN,
                        generated_link,
                        machine_name,
                        location
                    )
        os.system(curl_cmd)

    def get_geo_location(self):
        """ Makes use of freegeoip API to get current location """

        # freegeoip is an open sourced server
        # url = "https://freegeoip.app/json/"

        cmd = ("curl -k --request GET --url https://freegeoip.app/json/ "
               "--header 'accept: application/json' "
               "--header 'content-type: application/json'")
        output_status = subprocess.Popen(args=cmd, stdout=subprocess.PIPE, shell=True)
        (out, err) = output_status.communicate()

        try:
            data = json.loads(out)
            location_info = "{}, {}, {}".format(data["city"],
                    data["region_name"], data["country_name"])
            return location_info

        except Exception as e:
            return "Unable to retrieve region"

    def run(self):
        """ Script will execute upon detection of active LAN port by NetworkManager """
        #  First kill all existing NGROK sessions if any
        os.system("pkill -9 -f ngrok")

        count = 0
        connected_flag = False
        while count < 3:
            # Check ethernet statuses
            cmd = "nmcli dev status | grep ethernet"
            output_status = subprocess.Popen(args=cmd, stdout=subprocess.PIPE, shell=True)
            (out, err) = output_status.communicate()
            arr = out.split('\n')

            for line in arr:
            #  Based on the assumption that both ports will be plugged
                if ("unavailable") not in line:
                    print("Already connected")
                    connected_flag = True
                    break
                else:
                    print("Not connected yet")

            if connected_flag is False:
                if output_status != 0: # 1024 is error code for unable to connect
                    print("retry...")
                    count += 1
                    # Wait 1 sec for next try
                    time.sleep(1)
                    continue
                else:
                    connected_flag = True

            if connected_flag is True:
                break

        #  Once connected, run generate link
        if connected_flag:
            # Should delete Robot cable connection from default port
            # and then try to check internet connection.
            # First remove default gateway of connection between two PCs
            for _ip in settings.DEL_GW_IPS:
                os.system("sudo route del default gw {}".format(_ip))

            if self._has_internet():

                link = self.generate_link()
                location = self.get_geo_location()
                self.send_link(link, location)

                # FIXME: temp disabled
                # if (self.username == 'augbooth'
                #     and hasattr(settings, 'DINGTALK_ANALYSIS_TOKEN')):
                #     # Lazily importing to reduce unnecessary overhead
                #     from analysis_report import get_summary, send_summary
                #     summary = get_summary()
                #     send_summary(summary, location)
            else:
                print("No internet connection. Do nothing!")
        else:
            print("Please replug lan port. Not connected.")

    def _has_internet(self):
        # Check internet connection 3 times at most.
        for i in range(3):
            try:
                ping_output = subprocess.check_output(
                    ['ping', '-c', '1', '{}'.format(settings.PING_SITE)]
                )
                if '100% packet loss' not in ping_output:
                    return True
            except CalledProcessError as e:
                pass
            
            time.sleep(1)
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('username', nargs='?', type=str)
    args = parser.parse_args()
    username = args.username
    if username == 'augbooth':
        hn = os.uname()[1] # idx 1 is hostname
        if hn.startswith("i5"):
            port = settings.I5_PC_PORT
        else:
            port = settings.BIG_PC_PORT
    else:
        port = settings.SMALL_PC_PORT

    # NetworkManager scripts have no $HOME environment variable
    if not "HOME" in os.environ:
        os.environ["HOME"] = "/home/{}".format(username)

    remote_connection = RemoteAccess(port, username)
    remote_connection.run()
