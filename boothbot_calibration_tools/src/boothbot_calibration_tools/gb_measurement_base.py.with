#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import print_function, division

import math
import rospy

logger = rospy
from boothbot_common.constants import ACTION_FINISH_TYPE
from guiding_beacon_system.constants import (
    GuidingBeaconStates as MS,
    GuidingBeaconCommands as CS,
    GbModuleErrorCode as EC,
)
from boothbot_common.error_code_constants import ServosDriverErrorCode
from boothbot_perception.settings import TargetTrackerStatus as TRState
from boothbot_common.settings import LASER_OFFSET
from guiding_beacon_system.modules.levelness_compensation import (
    inclinational_compensation,
    inverse_inclinational_compensation,
)
from guiding_beacon_system.modules.searching import SearchingOffsetsGenerator
from boothbot_common.utils import equal_point
import guiding_beacon_system_msgs.msg as gbmsgs

NAME = "guiding_station"

from boothbot_common.module_base import ModuleBase

# TODO: Should be get from device_setting instead
LONG_CAM_MIN_TRACKING_DIST = 3.0
MEASURE_MAXIMUM_DIFFERENCE = 2.0

TRANSITIONS_TOP = [
    {
        # Error state manual entrance
        "trigger": "to_ERROR",
        "source": "*",
        "dest": MS.ERROR,
        "unless": ["is_ERROR"],
    },
    {
        # now we reset the machine
        "trigger": "reset",
        "source": "*",
        "dest": MS.RESETING,
        "unless": ["is_RESETING"],
    },
    {
        # to idle state after reseting
        "trigger": "to_IDLE",
        "source": [MS.RESETING],
        "dest": MS.IDLE,
    },
    {
        # Will back to INIT if initialize failed
        "trigger": "to_INIT",
        "source": [MS.RESETING],
        "dest": MS.INIT,
    },
]

TRANSITIONS = TRANSITIONS_TOP + [
    {
        "trigger": "measure",
        "source": MS.IDLE,
        "dest": MS.RUNNING,
    },
]


class GuidingBeaconGoalCarrier(object):
    MEASUREMENT_RESULT_MSG = """
    Laser results: {0}, {1:.4f}, {2:.4f}
    at             ({3[0]:+.5f}, {3[1]:+.5f})
    current_radians({4[0]:+.5f}, {4[1]:+.5f})
    """

    def __init__(self, action_goal):
        logger.loginfo("Received goal: {}".format(action_goal))
        self.action_goal = action_goal
        self.tracked_times = 0
        self.result = {
            "stamp": rospy.Time(),
            "located": False,
            "laser_distance": 0.0,
            "laser_angle": 0.0,
            "radians_original": [0.0, 0.0],
            "radians_compensated": [0.0, 0.0],
        }
        self.set_target_radians([self.action_goal.rad_hor, self.action_goal.rad_ver])
        self.searching_offsets_generator = SearchingOffsetsGenerator(
            exp_distance=self.exp_dist,
            is_initialpose=self.action_goal.is_initialpose,
        )

    def update_target_radians_with_offset(self, current_radians, offsets):
        logger.loginfo("Update tracking result offset: {} to target".format(offsets))
        # updated_offsets = [x * math.exp(-abs(x * 0.1)) for x in offsets]
        updated_offsets = offsets
        self.set_target_radians(
            map(lambda x, y: x + y, current_radians, updated_offsets)
        )
        return True

    def update_target_radians_with_searching(self):
        # always based on original goal target. generate a seraching offsets for server to track
        searching_offsets = self.searching_offsets_generator.get_next_searching_offsets()
        if searching_offsets:
            self.set_target_radians(
                (
                    self.action_goal.rad_hor + searching_offsets[0],
                    self.action_goal.rad_ver + searching_offsets[1],
                )
            )
            return True
        return False

    def set_target_radians(self, radians):
        self.target_radians = radians
        logger.loginfo("Target radians are set to: {}".format(self.target_radians))

    def set_measurement_result(
        self,
        stamp,
        located,
        laser_distance,
        laser_angle,
        radians_original,
        radians_compensated,
    ):
        self.result = {
            "stamp": stamp,
            "located": located,
            "laser_distance": laser_distance,
            "laser_angle": laser_angle,
            "radians_original": radians_original,
            "radians_compensated": radians_compensated,
        }
        logger.loginfo(
            self.MEASUREMENT_RESULT_MSG.format(
                True, laser_distance, laser_angle, radians_compensated, radians_original
            )
        )

    def gen_action_result(self):
        # self.action_goal = gbmsgs.GBMeasureGoal()
        res = gbmsgs.GBMeasureResult(
            gid=self.action_goal.gid,
            located=self.result["located"],
            state="DONE", # Deprecating...
            color=self.action_goal.color,
            distance=self.result["laser_distance"],
            rad_hor=self.result["radians_compensated"][0],
            rad_ver=self.result["radians_compensated"][1],
        )
        res.header.stamp = rospy.Time.now()
        return res

    @property
    def color(self):
        return self.action_goal.color

    @property
    def exp_dist(self):
        return self.action_goal.distance

    @property
    def exp_ver_ang(self):
        return self.action_goal.rad_ver


class GuidingBeaconMeasurementModuleBase(ModuleBase):
    RESET_WAIT_TIMEOUT = rospy.Duration(0.5)
    def __init__(
        self,
        name,
        rate,
        status_inf,
        srv_cmd_inf,
        pdo_inf,
        action_inf,
        tracker,
        servos,
        laser,
        inclination_inf,
        tolerance,
    ):
        super(GuidingBeaconMeasurementModuleBase, self).__init__(
            name=name,
            rate=rate,
            states=MS,
            transitions=TRANSITIONS,
            commands=CS,
            status_inf=status_inf,
            srv_cmd_inf=srv_cmd_inf,
            # need_robot_status=True,
        )
        self.ON_STATE_METHODS.update(
            {
                MS.INIT: [self.on_INIT],
                MS.RESETING: [self.on_RESETING],
                MS.IDLE: [self.on_IDLE],
                MS.RUNNING: [self.on_RUNNING],
                MS.ERROR: [],
            }
        )
        self.tracker = tracker
        self.servos = servos
        self.laser = laser
        self._pdo_inf = pdo_inf
        self.action_server = action_inf.SimpleActionServer()
        self._inclination_inf = inclination_inf
        self.inclination = [0.0, 0.0, 0.0]
        self.inclination_cb = [0.00627567756464, -0.000463818458434 , 0.0]


        
        # self.tolerance = tolerance
        self.loose_beacon_check_tolerance = [3*i for i in tolerance] # for short camera result
        self.tight_beacon_check_tolerance = tolerance   # for long camera result

        self._reset_wait_timer = rospy.Time.now()
        self.action_timer = rospy.Time.now()

    def publish_pdo(self):
        msg_pdo = self._pdo_inf.type()
        msg_pdo.stamp = rospy.Time.now()
        #     msg_pdo.outputs = self.runtime_data["outputs"].tolist()
        #     msg_pdo.inputs = self.runtime_data["inputs"].tolist()
        #     msg_pdo.cmd_outputs = self.runtime_data["cmd_outputs"].tolist()
        #     msg_pdo.auto_reset_remaining = self.auto_reset_remaining.tolist()
        self.pub_pdo.publish(msg_pdo)

    def _inclination_cb(self, msg):
        self.inclination = msg.data

    ############################################################################
    # Inherited API
    ############################################################################
    def initialize(self):
        """
        Deprecating...
        """
        return True

    def handle_inputs(self, command):
        if CS.RESET == command:
            self.beacon_switch(on=False)
            self.reset()
        elif CS.LASER_ON == command:
            self.laser_switch(on=True)
        elif CS.LASER_OFF == command:
            self.laser_switch(on=False)

        return True

    ############################################################################
    # On state methods
    ############################################################################
    def on_INIT(self):
        self.initialized = False
        logger.loginfo("Initializing tracker, servos and laser...")
        initialized = True
        for client in (self.tracker, self.servos, self.laser):
            if not client.connect(timeout=0.5):
                logger.logwarn("Initializing {} failed!!".format(client.name))
                initialized = False

        if not initialized:
            return False

        if self._inclination_inf:
            logger.loginfo("Inclination compensation enabled!")
            logger.loginfo("Subscribing {} ...".format(self._inclination_inf.name))
            self._inclination_inf.Subscriber(callback=self._inclination_cb)
        else:
            logger.logwarn("Inclination compensation disabled!")

        logger.loginfo("Publishing {} ...".format(self._pdo_inf.name))
        self.pub_pdo = self._pdo_inf.Publisher()

        logger.loginfo("Creating action server...")
        self.action_server.start()

        self.initialized = True
        self.reset()
        return True

    def on_RESETING(self):
        # 1. reset sub modules to origin state
        if self.initialized is False:
            logger.logwarn("Initialization failed, will try again")
            self.to_INIT()
        else:
            if self.sub_state == 0:
                self.finish_action()
                self.goal = None
                # trigger submodules to reset
                for client in (self.tracker, self.servos, self.laser):
                    client.reset()
                self._reset_wait_timer = rospy.Time.now() + self.RESET_WAIT_TIMEOUT
                self.sub_state = 1
            elif self.sub_state == 1:
                # TODO: check timeout
                if rospy.Time.now() > self._reset_wait_timer:
                    for client in (self.tracker, self.servos, self.laser):
                        if not client.is_ready():
                            # TODO: log
                            logger.loginfo(
                                "{} is not ready, keep waiting...".format(client.name)
                            )
                            logger.logwarn(
                                "Will resend reset command to {}!".format(client.name)
                            )
                            client.reset()
                            self._reset_wait_timer = rospy.Time.now() + self.RESET_WAIT_TIMEOUT
                            return False

                if not self.laser.error:
                    self.del_error(EC.Laser_error.value)
                # We need the gbm to control CB's BEACON off, in case GS not finished yet.
                # self.beacon_switch(on=False)
                logger.loginfo("Reset succeeded!")
                self.to_IDLE()
                return True
        return False

    def on_IDLE(self):
        self.publish_pdo()
        if self.check_goal():
            self.measure()
            self.beacon_switch(on=True)
            return True
        return False

    def on_RUNNING(self):
        """
        substates:
        0. check fail times, if more than 2, finish goal with failed
            set tracking target radian, set servos goal
        1. check servos arrived or not,
            if arrived, check offset, if too big, update target radian, back to 0
            if within tolerance, trigger laser, succeeded than finish, set failed add errorcode back to 0
            if not found, get searching setting, update target radian, back to 0
                if searching list run out, set failed.
        """
        self.publish_pdo()
        if self.sub_state == 0:
            # TODO: check fail times
            # TODO: added levelness compensation
            self.laser_switch()
            self.set_servos_move_to(self.goal.target_radians, compensation=True)
            self.sub_state = 1
        elif self.sub_state == 1:
            if self.servos.is_timeout():
                logger.logwarn("Servos running timeout, set failed!")
                self.reset()
            elif self.servos.is_succeeded():
                # 1. get current radians, calculate without compensation
                # 2. check offsets
                # in tolerance: trigger laser
                # out tolerance: update target_radians with offset
                # no beacon found: update target_radians with searching radians list
                self.goal.tracked_times += 1
                servos_radians = self.get_servos_radians()
                logger.loginfo("Tracking at: {}".format(servos_radians))
                c_state, offsets = self.track_and_wait_result()
                if c_state == TRState.OUT:
                    self.sub_module_failed_operate()
                elif self.check_beacon_locked(offsets):
                    self.loginfo("Now get laser result....")
                    (
                        located,
                        laser_distance,
                        laser_angle,
                    ) = self.get_laser_result()
                    self.loginfo("Laser result checking... located is [{}]; laser_distance is [{}]; laser angle is [{}]".format(located,laser_distance,laser_angle))
                    if located:
                        logger.loginfo("Beacon measured!")
                        if self._inclination_inf:
                            servos_radians_compensated_lb = (
                                inverse_inclinational_compensation(
                                    servos_radians[0],
                                    servos_radians[1],
                                    self.inclination,
                                )
                            )
                            servos_radians_compensated = (
                                                   inverse_inclinational_compensation(
                                                                servos_radians_compensated_lb[0],
                                                                servos_radians_compensated_lb[1],
                                                                self.inclination_cb   ))
                        else:
                            logger.loginfo("No compensation avaiable!")
                            servos_radians_compensated = servos_radians
                        self.goal.set_measurement_result(
                            stamp=rospy.Time.now(),
                            located=True,
                            laser_distance=laser_distance,
                            laser_angle=laser_angle,
                            radians_original=servos_radians,
                            radians_compensated=servos_radians_compensated,
                        )
                        logger.loginfo("Target radians are servos_radians_compensated_lb to: {}".format(servos_radians_compensated_lb))
                        logger.loginfo("Target radians are servos_radians_compensated to: {}".format(servos_radians_compensated))
                        logger.loginfo("Target radians are radians_compensated to: {}".format(radians_compensated))
                        self.finish_action(ACTION_FINISH_TYPE.SUCCEEDED)
                    else:
                        logger.loginfo("Beacon measure failed!")
                        self.add_error(EC.Laser_measurement_failed.value)

                    self.reset()
                else:
                    self.goal.update_target_radians_with_offset(servos_radians, offsets)
                    self.set_servos_move_to(
                        self.goal.target_radians, compensation=False
                    )
            elif self.servos.is_failed():
                _servos_result = self.servos.get_result()
                if _servos_result:
                    servos_error_code = self.servos.get_result().error_code
                    logger.loginfo_throttle(1, "Servo is failed, due to: {}".format(servos_error_code))
                    if ServosDriverErrorCode.Over_hardware_limit.value in servos_error_code:
                        self.sub_module_failed_operate()
                else:
                    logger.loginfo_throttle(1, "Servo is Lost")
                self.reset()

            elif self.servos.is_active():
                logger.loginfo_throttle(1., "Servo is running....")

    ############################################################################
    # Action server operation
    ############################################################################
    def check_goal(self):
        """
        Return True if valid action goal for marking
        """
        if self.action_server.is_new_goal_available():
            action_goal = self.action_server.accept_new_goal()
            self.goal = GuidingBeaconGoalCarrier(action_goal=action_goal)
            self.del_error(EC.Last_goal_failed.value)
            self.del_error(EC.Laser_measurement_failed.value)
            # if the new goal was set to preempted already
            if self.action_server.is_preempt_requested():
                self.finish_action(endwith=ACTION_FINISH_TYPE.PREEMPTED)
                self.goal = None
                return False
        if self.goal is not None:
            self.action_timer = rospy.Time.now()
            return True
        return False

    def finish_action(self, endwith=ACTION_FINISH_TYPE.ABORTED):
        if self.action_server.is_active():
            logger.loginfo("Finishing action with: {}".format(endwith))
            logger.logwarn("Action took: {}s".format((rospy.Time.now() - self.action_timer).to_sec()))
            res = self.goal.gen_action_result()
            if endwith is ACTION_FINISH_TYPE.ABORTED:
                self.add_error(EC.Last_goal_failed.value)
                # should prepare errorcodes here
                self.action_server.set_aborted(res)
            elif endwith is ACTION_FINISH_TYPE.PREEMPTED:
                self.add_error(EC.Last_goal_failed.value)
                # should prepare errorcodes here
                self.action_server.set_preempted(res)
            elif endwith is ACTION_FINISH_TYPE.SUCCEEDED:
                # should prepare errorcodes here
                self.action_server.set_succeeded(res)

    ############################################################################
    # Sub module operation
    ############################################################################
    def sub_module_failed_operate(self):
        if self.goal.update_target_radians_with_searching():
            logger.loginfo("No result, will keep searching...")
            self.set_servos_move_to(self.goal.target_radians, compensation=True)
        else:
            logger.loginfo("Done searching list, this goal failed.")
            self.reset()

    def beacon_switch(self, on=True):
        if on:
            logger.loginfo("Turning on beacon...")
        else:
            logger.loginfo("Turning off beacon...")
        return True

    def laser_switch(self, on=True):
        if on:
            logger.loginfo("Turning on laser...")
            self.laser.laser_on()
        else:
            logger.loginfo("Turning off laser...")
            self.laser.laser_off()
        if self.laser.error:
            self.add_error(EC.Laser_error.value)
        return True

    def track_and_wait_result(self):
        self.loginfo("track_and_wait_result")
        c_state, offsets = self.tracker.trigger(
            self.goal.color,
            exp_dist=self.goal.exp_dist,
        )
        self.loginfo("track_and_wait_result done")
        return c_state, offsets

    def check_beacon_locked(self, offsets):
        if self.goal.exp_dist < LONG_CAM_MIN_TRACKING_DIST:
            logger.logwarn("Within Short Camera Distance, will use loose tolerance for beacon check !")
            _tolerance = self.loose_beacon_check_tolerance
        else:
            _tolerance = self.tight_beacon_check_tolerance
        logger.loginfo("Beacon Check tolerance: {}".format(_tolerance))
        _is_locked = equal_point(offsets, (0.0, 0.0), tolerance=_tolerance)
        logger.loginfo("Beacon is locked: {}".format(_is_locked))
        return _is_locked

    def get_laser_result(self):
        (
            located,
            laser_distance,
            laser_angle,
        ) = self.laser.get_distance_full()
        if self.laser.error:
            self.add_error(EC.Laser_error.value)
        dis_comp, ppm = LASER_OFFSET
        return (
            located,
            (laser_distance + dis_comp) * (1 + ppm),
            laser_angle,
        )

    def set_servos_move_to(self, radians, compensation=True):
        if not self._inclination_inf:
            logger.loginfo("No compensation available, will not change servos goal")
            compensation = False
        if compensation:
            copnsad_lb = inclinational_compensation(
                radians[0],
                radians[1],
                self.inclination,
            )
            copnsad = (
                    inclinational_compensation(

                                            copnsad_lb[0],
                                            copnsad_lb[1],
                                            self.inclination_cb
                        )
                    )
            logger.loginfo("Target radians are compensated_lb to: {}".format(copnsad_lb))
            logger.loginfo("Target radians are compensated to: {}".format(copnsad))
        else:
            copnsad = (radians[0], radians[1])
        # TODO: should we check servos limits here?
        self.servos.move_to(copnsad)
        logger.loginfo("Moving to: {}".format(copnsad))
        return True

    def get_servos_radians(self):
        return self.servos.get_arrived_radians()
